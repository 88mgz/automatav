"use client"

import type React from "react"

import { useState, useEffect } from "react"
import { motion, AnimatePresence } from "framer-motion"
import {
  Sparkles,
  Eye,
  Upload,
  Loader2,
  Download,
  Copy,
  Check,
  AlertCircle,
  Wand2,
  FileJson,
  ChevronDown,
  ChevronUp,
} from "lucide-react"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import { Textarea } from "@/components/ui/textarea"
import { ArticleView } from "@/components/ArticleView"
import { parseArticle, type Article } from "@/lib/articleSchema"
import { useToast } from "@/hooks/use-toast"
import { Alert, AlertDescription } from "@/components/ui/alert"
import { LiquidBlobs } from "@/components/visual/LiquidBlobs"

/** Build a strict prompt the API expects (we will POST { prompt }) */
function buildPrompt(input: {
  title: string
  tldr?: string
  keyTakeaways?: string[]
  quizInstructions?: string
  calculatorInstructions?: string
  pullQuote?: string
  pullQuoteAttribution?: string
  dropdownTitle?: string
  dropdownBody?: string
  reviewsInstructions?: string
  models?: any[]
}) {
  const {
    title,
    tldr = "",
    keyTakeaways = [],
    quizInstructions = "",
    calculatorInstructions = "",
    pullQuote = "",
    pullQuoteAttribution = "",
    dropdownTitle = "",
    dropdownBody = "",
    reviewsInstructions = "",
    models = [],
  } = input

  return `
You are an assistant that outputs ONLY compact JSON matching this Zod schema (no prose):

Article = {
  title: string
  slug: string
  description?: string
  intent: "comparison"|"review"|"guide"|"localized_dealer"
  hero?: {
    headline?: string
    subheadline?: string
    subtitle?: string
    image?: string | { url: string, alt?: string }
  }
  toc: string[]
  blocks: Array<
    | { type: "intro", text: string }
    | { type: "comparisonTable", items: Array<{ name: string, [k: string]: any }>}
    | { type: "specGrid", items: Array<{ name: string, [k: string]: any }>}
    | { type: "prosCons", pros: string[], cons: string[] }
    | { type: "gallery", images: Array<{ url: string, alt?: string }>}
    | { type: "faq", items: Array<{ q: string, a: string }>}
    | { type: "ctaBanner", headline: string, body?: string }
    | { type: "markdown", content: string }
  >
  modules?: Array<any>
}

Requirements:
- Include a non-empty "toc" array.
- Prefer block types listed above; if you need free text, use { "type":"markdown", "content": string }.
- If you include images, alt text is preferred.

Title: ${title}
Models JSON (optional): ${JSON.stringify(models)}
Module instructions:
- tldr: ${tldr}
- key takeaways: ${JSON.stringify(keyTakeaways)}
- quiz: ${quizInstructions}
- calculator: ${calculatorInstructions}
- pull quote: ${pullQuote} (by ${pullQuoteAttribution})
- dropdown: title=${dropdownTitle}; body=${dropdownBody}
- reviews: ${reviewsInstructions}

Return ONLY JSON.
  `.trim()
}

/** Normalize model JSON so it passes articleSchema more reliably */
const coerceForSchema = (input: any): any => {
  const allowed = new Set([
    "intro",
    "comparisonTable",
    "specGrid",
    "prosCons",
    "gallery",
    "faq",
    "ctaBanner",
    "markdown",
  ])
  const a = input && typeof input === "object" ? { ...input } : {}

  // toc required
  if (!("toc" in a) || a.toc == null) a.toc = []

  // modules must be array; if object, drop it (optional)
  if (a.modules && !Array.isArray(a.modules)) {
    delete a.modules
  }

  // normalize blocks
  if (!Array.isArray(a.blocks)) a.blocks = []
  a.blocks = a.blocks.map((b: any) => {
    const t = b?.type
    // map unknown types to markdown
    if (!allowed.has(t)) {
      const content = typeof b === "string" ? b : b?.content ?? b?.text ?? JSON.stringify(b)
      return { type: "markdown", content: String(content || "") }
    }
    if (t === "intro") {
      const text = b?.text ?? b?.content ?? ""
      return { ...b, type: "intro", text }
    }
    if (t === "markdown" && !("content" in b)) {
      const content = b?.content ?? b?.text ?? ""
      return { ...b, type: "markdown", content }
    }
    return b
  })
  return a
}

const SAMPLE_DATA = {
  title: "2026 Midsize Sedan Comparison: Honda Accord vs Toyota Camry vs Mazda6",
  tldr: "The 2026 Honda Accord, Toyota Camry, and Mazda6 represent the best midsize sedans on the market. The Accord excels in fuel economy and cargo space, the Camry offers legendary reliability and available AWD, while the Mazda6 provides upscale styling at the lowest price.",
  keyTakeaways: [
    "Honda Accord leads in cargo space with 16.7 cubic feet",
    "Toyota Camry achieves best highway fuel economy at 39 MPG",
    "Mazda6 offers lowest starting price at $26,950",
    "All three sedans feature standard advanced safety systems",
  ],
  quizInstructions:
    "Create a 4-question quiz to help users determine which sedan best fits their needs. Focus on priorities like fuel economy, cargo space, AWD, and budget.",
  calculatorInstructions:
    "MPG calculator with defaults: City MPG: 30, Highway MPG: 38, Fuel Price: $3.50, Annual Miles: 12,000",
  pullQuote:
    "The Honda Accord continues to set the benchmark for midsize sedans with its perfect blend of efficiency, space, and driving dynamics.",
  pullQuoteAttribution: "Car and Driver, 2026 Review",
  dropdownTitle: "Understanding CVT Transmissions",
  dropdownBody:
    "Continuously Variable Transmissions (CVTs) are used in both the Honda Accord and Toyota Camry. Unlike traditional automatic transmissions with fixed gears, CVTs use a belt and pulley system to provide seamless acceleration and optimal fuel efficiency.",
  reviewsInstructions:
    "Generate 3 expert reviews from Car and Driver, Motor Trend, and Edmunds. Include ratings, pros, cons, and summaries for each vehicle.",
}

function CollapsibleSection({
  title,
  children,
  defaultOpen = false,
}: { title: string; children: React.ReactNode; defaultOpen?: boolean }) {
  const [isOpen, setIsOpen] = useState(defaultOpen)

  return (
    <div className="border border-slate-200 dark:border-slate-800 rounded-lg overflow-hidden">
      <button
        onClick={() => setIsOpen(!isOpen)}
        className="w-full px-4 py-3 flex items-center justify-between bg-slate-50 dark:bg-slate-900/50 hover:bg-slate-100 dark:hover:bg-slate-900 transition-colors"
      >
        <span className="font-medium text-sm">{title}</span>
        {isOpen ? <ChevronUp className="w-4 h-4" /> : <ChevronDown className="w-4 h-4" />}
      </button>
      <AnimatePresence>
        {isOpen && (
          <motion.div
            initial={{ height: 0, opacity: 0 }}
            animate={{ height: "auto", opacity: 1 }}
            exit={{ height: 0, opacity: 0 }}
            transition={{ duration: 0.2 }}
            className="overflow-hidden"
          >
            <div className="p-4 space-y-4">{children}</div>
          </motion.div>
        )}
      </AnimatePresence>
    </div>
  )
}

export default function GeneratePage() {
  const [formData, setFormData] = useState({
    title: "",
    tldr: "",
    keyTakeaways: "",
    quizInstructions: "",
    calculatorInstructions: "",
    pullQuote: "",
    pullQuoteAttribution: "",
    dropdownTitle: "",
    dropdownBody: "",
    reviewsInstructions: "",
    modelsJson: "",
  })

  const [loading, setLoading] = useState(false)
  const [publishing, setPublishing] = useState(false)
  const [error, setError] = useState("")
  const [generatedArticle, setGeneratedArticle] = useState<Article | null>(null)
  const [validationErrors, setValidationErrors] = useState<string[]>([])
  const [publishedUrl, setPublishedUrl] = useState("")
  const [copied, setCopied] = useState(false)
  const { toast } = useToast()

  useEffect(() => {
    const handleKeyPress = (e: KeyboardEvent) => {
      if (e.ctrlKey && e.key === "g") {
        e.preventDefault()
        handleGenerate()
      }
      if (e.ctrlKey && e.key === "p") {
        e.preventDefault()
        if (generatedArticle) handlePublish()
      }
      if (e.ctrlKey && e.key === "l") {
        e.preventDefault()
        loadSampleData()
      }
    }

    window.addEventListener("keydown", handleKeyPress)
    return () => window.removeEventListener("keydown", handleKeyPress)
  }, [formData, generatedArticle])

  const loadSampleData = () => {
    setFormData({
      title: SAMPLE_DATA.title,
      tldr: SAMPLE_DATA.tldr,
      keyTakeaways: SAMPLE_DATA.keyTakeaways.join("\n"),
      quizInstructions: SAMPLE_DATA.quizInstructions,
      calculatorInstructions: SAMPLE_DATA.calculatorInstructions,
      pullQuote: SAMPLE_DATA.pullQuote,
      pullQuoteAttribution: SAMPLE_DATA.pullQuoteAttribution,
      dropdownTitle: SAMPLE_DATA.dropdownTitle,
      dropdownBody: SAMPLE_DATA.dropdownBody,
      reviewsInstructions: SAMPLE_DATA.reviewsInstructions,
      modelsJson: JSON.stringify(
        [
          { name: "2026 Honda Accord", hp: 192, mpg: 38, price: 27950 },
          { name: "2026 Toyota Camry", hp: 203, mpg: 39, price: 27950 },
          { name: "2026 Mazda6", hp: 187, mpg: 35, price: 26950 },
        ],
        null,
        2,
      ),
    })
    toast({
      title: "Sample data loaded",
      description: "All fields have been populated with example content",
    })
  }

  const handleGenerate = async () => {
    if (!formData.title) {
      toast({
        title: "Title required",
        description: "Please enter a title for your article",
        variant: "destructive",
      })
      return
    }

    setLoading(true)
    setError("")
    setPublishedUrl("")
    setGeneratedArticle(null)
    setValidationErrors([])

    try {
      let models: any[] = []
      if (formData.modelsJson.trim()) {
        try {
          models = JSON.parse(formData.modelsJson)
        } catch {
          throw new Error("Invalid JSON in models field. Please check your syntax.")
        }
      }

      // Build a single prompt for the API
      const prompt = buildPrompt({
        title: formData.title,
        tldr: formData.tldr,
        keyTakeaways: formData.keyTakeaways.split("\n").filter(Boolean),
        quizInstructions: formData.quizInstructions,
        calculatorInstructions: formData.calculatorInstructions,
        pullQuote: formData.pullQuote,
        pullQuoteAttribution: formData.pullQuoteAttribution,
        dropdownTitle: formData.dropdownTitle,
        dropdownBody: formData.dropdownBody,
        reviewsInstructions: formData.reviewsInstructions,
        models,
      })

      const prompt = buildPrompt({
        title: formData.title,
        models: models.length ? models : undefined,
        instructions: {
          tldr: formData.tldr,
          keyTakeaways: formData.keyTakeaways.split("\n").filter(Boolean),
          quizInstructions: formData.quizInstructions,
          calculatorInstructions: formData.calculatorInstructions,
          pullQuote: formData.pullQuote,
          pullQuoteAttribution: formData.pullQuoteAttribution,
          dropdownTitle: formData.dropdownTitle,
          dropdownBody: formData.dropdownBody,
          reviewsInstructions: formData.reviewsInstructions,
        },
      });
      const response = await fetch("/api/generate", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ prompt }),
